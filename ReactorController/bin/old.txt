local FPS=1 / 10 local PORT=3000 local REACTOR_PROTOCOL="RCT1" local f13=0.4 local f14=0.9 local f15=0.1 local f16=1 local f17=0.3 local reactor={}local m=component.proxy(component.list("modem")())function f1(timeout)checkArg(1,timeout,"number","nil")local deadline=computer.uptime()+(timeout or 0)repeat computer.pullSignal(deadline - computer.uptime())until computer.uptime()>=deadline end function f2(a)local b=""local c=type(a)if c=="number"then b=b..a elseif c=="boolean"then b=b..tostring(a)elseif c=="string"then b=b..string.format("%q",a)elseif c=="table"then b=b.."{"for d,e in pairs(a)do b=b.."["..f2(d).."]="..f2(e)..","end;b=b.."}"else error("cannot f2 a "..c)end;return b end function broadcast(packet)local data=f2(packet)m.broadcast(PORT,REACTOR_PROTOCOL .. data)end function initModem()if not m.isOpen(PORT)then m.open(PORT)end end function f3()if m.isOpen(PORT)then m.close(PORT)end end function f4()local fission=component.list("nc_fission_reactor")()local fusion=component.list("nc_fusion_reactor")()if fission ~=nil then reactor=component.proxy(fission)return "fission" end if fusion ~=nil then reactor=component.proxy(fusion)return "fusion" end return nil end local heat=0 local maxHeat=0 local power=0 local maxPower=0 local processTime=0 local maxProcessTime=0 local efficiency=100 local isOn=false local computerEnergy=0 local maxComputerEnergy=0 local controllerReason="Intermission" local controllerType=f4()function f5()local t=maxProcessTime if maxProcessTime==0 then t=1 end local packet={type="REACTOR_STATE",heat=heat / maxHeat,power=power / maxPower,time=processTime / t,efficiency=efficiency,isOn=isOn}broadcast(packet)end function f6()local reactorType=controllerType if not reactorType then reactorType="none" end local packet={type="CONTROLLER_STATE",reason=controllerReason,power=computerEnergy / maxComputerEnergy,reactorType=reactorType}broadcast(packet)end function stop()if isOn then reactor.deactivate()end end function start()if not isOn then reactor.activate()end end function getTemp()if controllerType=="fission" then return reactor.getHeatLevel()else return reactor.getTemperature()end end function getMaxTemp()if controllerType=="fission" then return reactor.getMaxHeatLevel()else return reactor.getMaxTemperature()end end function f7()return reactor.getEnergyStored()end function f8()return reactor.getMaxEnergyStored()end function f9()return reactor.getCurrentProcessTime()end function f10()return reactor.getReactorProcessTime()end function f12()if controllerType=="fission" then return 100 else return reactor.getEfficiency()end end function f11()return reactor.isProcessing()end function update()heat=getTemp()maxHeat=getMaxTemp()power=f7()maxPower=f8()processTime=f9()maxProcessTime=f10()isOn=f11()efficiency=f12()computerEnergy=computer.energy()maxComputerEnergy=computer.maxEnergy()end local RUNNING="Reactor is active" local EFF_OVER="Cooling down,efficiency lowering" local POW_LOW="FATAL: CONTROLLER LOSING POWER" local lastSwitchUptime=0 local switchTime=5 local lastEff=0 function run()local _heat=heat / maxHeat local _power=power / maxPower local _computerEnergy=computerEnergy / maxComputerEnergy local _eff=efficiency local isEffUp=false if lastEff <=isEffUp then isEffUp=true end if _computerEnergy <=f17 then controllerReason=POW_LOW stop()return end if lastSwitchUptime + switchTime > computer.uptime()then return end if not isEffUp and isOn then stop()controllerReason=EFF_OVER switchTime=computer.uptime()elseif not isEffUp and not isOn then start()controllerReason=RUNNING switchTime=computer.uptime()end end stop()initModem()while true do update()run()f5()f6()f1(FPS)end f3()